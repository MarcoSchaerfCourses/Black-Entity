<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=windows-1252">
</head>

<body style="margin: 0px; background-color: #3f3f3f; overflow: hidden;">
	<script src="three.min.js"></script>
	<script src="threex.proceduralcity2.js"></script>
	<script src="FirstPersonControls.js"></script>
	<script src="CylinderGeometry.js"></script>
	<script src="jquery-1.7.2.min.js"></script>


<p id="time" align="center"></p>
<p id="ris" align="center"></p>
<script>


var map = [ // 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17
          		[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,], // 0
           		[1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,], // 1
           		[1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,], // 2
         	    [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,], // 3
        	    [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,], // 4
           		[1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,], // 5
           		[1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,], // 6
           		[1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,], // 7
           		[1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,], // 8
           		[1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,], // 9
          	    [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,], // 10
           		[1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,], //11
           		[1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,], // 12
           		[1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,], // 13
           		[1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,], // 14
				[1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,], // 15
				[1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,], // 16
           		[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, ], //17
           ], mapW = map.length, mapH = map[0].length;

 	var pun = 0;
  var tempo = 10;
  var	UNITSIZE = 20,
	MOVESPEED = 300,
	LOOKSPEED = 1,
	BULLETMOVESPEED = MOVESPEED * 5,
	NUMAI = 100,
	DURATIONTIME=92000; //in millisec

  var t = THREE,renderer, clock, projector, model, skin;

    var renderer	= new THREE.WebGLRenderer
    ({
		antialiasing	: true
	});
	renderer.setSize( window.innerWidth, window.innerHeight );
	document.body.appendChild( renderer.domElement );
  var mouse = { x: 0, y: 0 };
  var ai = [];
	var updateFcts	= [];
	var scene	= new THREE.Scene();
	scene.fog	= new THREE.FogExp2( 0xd0e0f0, 0.0025 );
	var camera	= new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.3, 1000 );
	camera.position.z = 45;
    scene.add(camera);


	//////////////////////////////////////////////////////////////////////////////////
	//		comment								//
	//////////////////////////////////////////////////////////////////////////////////

	var proceduralCity = new THREEx.ProceduralCity()
	var mesh	= proceduralCity.createSquareCity()
	scene.add(mesh)


    setupAI();



	//////////////////////////////////////////////////////////////////////////////////
	//		add an object and make it move					//
	//////////////////////////////////////////////////////////////////////////////////

	var light	= new THREE.HemisphereLight( 0xfffff0, 0x101020, 1.25 );
	light.position.set( 1, 1, 0.25 );
	scene.add( light );


	// colosseum
	var texture = THREE.ImageUtils.loadTexture( '800px_COLOURBOX4176774.jpg' );
	var geometry = new THREE.CylinderGeometry( 5, 5, 20, 32 );
	var material = new THREE.MeshBasicMaterial( {map: texture, color:0x835C3B} );
    var cylinder = new THREE.Mesh( geometry, material );

	cylinder.position.set(2, 1.3, 10);
	cylinder.scale.set(3.5, 2, 4);
    scene.add( cylinder );

    // weapon
	var texture_weapon = THREE.ImageUtils.loadTexture( 'weapon.png' );
	var geometry_weapon = new THREE.CylinderGeometry(  5, 5, 20, 32 );
	var material_weapon = new THREE.MeshBasicMaterial( {map: texture_weapon, color:0xffffff} );
	var cylinder_weapon = new THREE.Mesh( geometry_weapon, material_weapon );

	cylinder_weapon.scale.set(0.05, 0.1, 0.05);
    cylinder_weapon.rotation.set(29.8, 0, 0);
    camera.add(cylinder_weapon);
    cylinder_weapon.position.set(0.7 ,-0.3, -1);


    // bullets
    var bullets = [];
    var canShoot = 0;
    var keyboard = {};

		projector = new THREE.Projector();
		var vector = new THREE.Vector3();




	//////////////////////////////////////////////////////////////////////////////////
	//		Camera Controls							//
	//////////////////////////////////////////////////////////////////////////////////

    camera.position.y = 1.85;
	camera.position.z = 200;

    var controls, clock;
	clock = new THREE.Clock();
    controls = new THREE.FirstPersonControls(camera);

    controls.movementSpeed = MOVESPEED;
    controls.lookSpeed = LOOKSPEED;
	controls.lookVertical = false; // Temporary solution; play on flat surfaces only
	controls.noFly = true;

	// Track mouse position so we know where to shoot
	document.addEventListener( 'mousemove', onDocumentMouseMove, false );

// Set the date we're counting down to
var date = new Date().getTime();
var countDownDate = date + DURATIONTIME;

// Update the count down every 1 second
var x = setInterval(function()
{
tempo -=1;
  // Get the "now" date
  var now1 = new Date().getTime();

  // Find the distance between now an the count down date
  var distance = countDownDate - now1;

var sec = Math.floor(distance/1000);
document.getElementById("time").innerHTML = "<span style='font-family: Impact; font-size: 15px; color:#00FF00'>  Remaining time: " + sec +" sec"+"&nbsp&nbsp&nbsp Punteggio: "+pun+"</span>";


  // If the count down is finished, write some text
  if (distance < 0) {
    clearInterval(x);
    document.getElementById("time").innerHTML = "<br /><span style='font-family: Impact; font-size: 60px; color:#00FF00'>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp <h1>TIME OUT!</h1></span>";
    document.getElementById("ris").innerHTML = "<span style='font-family: Impact; font-size: 60px; color:#00FF00'><h1> Score:  " + pun+ "</span>"+ "<br /><span style='font-family: Impact; font-size: 60px; color:#00FF00'>"+"<a href='index.php'> Restart</a>"+"</h1></span>";
    $(renderer.domElement).fadeOut();
  }
}, 1000);


	//////////////////////////////////////////////////////////////////////////////////
	//		render the scene						//
	//////////////////////////////////////////////////////////////////////////////////
	updateFcts.push(function()
	{


	pun =NUMAI - ai.length;

	var delta = clock.getDelta(), speed = delta * BULLETMOVESPEED;
	var aispeed = delta * MOVESPEED *0.1;
    var time = Date.now() * 0.0005;
    renderer.render( scene, camera );
    controls.update(clock.getDelta());
    castRays();


            // SHOOT BULLET
                    for(var index=0; index<bullets.length; index+=1){
                    if( bullets[index] === undefined ) continue;
                    if( bullets[index].alive == false ){
                    bullets.splice(index,1);
                    continue;
                    }

                    bullets[index].position.add(bullets[index].velocity);
                    }

                    if(keyboard[32] && canShoot <= 0){ // spacebar key

                    // creates a bullet as a Mesh object
                    var bullet = new THREE.Mesh(
                                                new THREE.SphereGeometry(0.2,8,8),
                                                new THREE.MeshBasicMaterial({color:0x42FFFF})
                                                );
                    // position the bullet to come from the player's weapon
                 /*   bullet.position.set(
                                        camera.position.x - 0.7*parseInt(-Math.cos(camera.rotation.z)),
                                        camera.position.y - 0.3,
                                        camera.position.z +1*parseInt(-Math.cos(camera.rotation.z))
                                        );
				*/
				bullet.position.set(
                                       camera.position.x - 0.7*parseInt(-Math.cos(camera.rotation.x)),
                                        camera.position.y - 0.3,
                                        camera.position.z
                                        );
				
                    // set the velocity of the bullet
                    bullet.velocity = new THREE.Vector3(
                                                       ((mouse.x*parseInt(Math.cos(camera.rotation.z))) - Math.sin(camera.rotation.y) * 0.75),//*parseInt(-Math.cos(camera.rotation.z)) ,
                                                        mouse.y,
                                                        Math.cos(camera.rotation.y)*parseInt(-Math.cos(camera.rotation.z))
																											).normalize();
                    bullet.alive = true;
                    setTimeout(function(){
                               bullet.alive = false;
                               scene.remove(bullet);
                               }, 1000);
                    // add to scene, array, and set the delay to 10 frames
                    bullets.push(bullet);
                    scene.add(bullet);
                    canShoot = 10;
                    }
                    if(canShoot > 0) canShoot -= 1;

  //  console.info(" Punteggio2: "+pun);

// COLLIDE WITH AI
for (var i = bullets.length-1; i >= 0; i--)
	{
		var b = bullets[i], p = b.position;
		//var hit = false;
		for (var j = ai.length-1; j >= 0; j--)
		{
			var a = ai[j];
			var v = a.geometry.vertices[0];
			var c = a.position;

			console.info(" V vale: "+ v);
			console.info("P.x vale: "+ p.x + " C.x vale: " + c.x + " P.z vale: " +p.z + " C.z vale: "+c.z);
			console.info(" Punteggio: "+pun);
					console.info(" ai e' lungo: "+ ai.length);
						if (p.x <= c.x + 2 && p.x >= c.x - 2 && p.z <= c.z + 2 && p.z >= c.z - 2)
			{
					var texture_hit1 = THREE.ImageUtils.loadTexture( 'spento.png' );
                    var material_hit1 = new THREE.MeshBasicMaterial( {map: texture_hit1, color:0xffffff} );
                    var geometry_hit1 = new THREE.CubeGeometry(5,4,5);
                    var hit1 = new THREE.Mesh( geometry_hit1, material_hit1 );
                    hit1.position.x = c.x;
                    hit1.position.y = c.y;
                    hit1.position.z = c.z;
                    scene.add(hit1);
                  var y = setInterval(function()
                 {
            	  scene.remove(hit1);
               	}, 500);
				ai.splice(j,1);
				scene.remove(a);
				bullets.splice(i,1);
				scene.remove(b);
				break;

			}
		}
	}

// Update AI.
	for (var i = ai.length-1; i >= 0; i--)
	{
		var a = ai[i];
		// Move AI
		var r = Math.random();
		if (r > 0.995) {
			a.lastRandomX = Math.random() * 2 - 1;
			a.lastRandomZ = Math.random() * 2 - 1;
		}
		a.translateX(aispeed * a.lastRandomX);
		a.translateZ(aispeed * a.lastRandomZ);
		var c = getMapSector(a.position);
		if (c.x < 0 || c.x >= mapW || c.y < 0 || c.y >= mapH ) {
			a.translateX(-2 * aispeed * a.lastRandomX);
			a.translateZ(-2 * aispeed * a.lastRandomZ);
			a.lastRandomX = Math.random() * 2 - 1;
			a.lastRandomZ = Math.random() * 2 - 1;
		}
		if (c.x < -1 || c.x > mapW || c.z < -1 || c.z > mapH) {
			ai.splice(i, 1);
			scene.remove(a);
			addAI();
		}

		var cc = getMapSector(camera.position);
	}
	})


	    // enemies

	var geometry_enemy1 = new THREE.CubeGeometry(5,4,5);
	function setupAI()
	{
		for (var i=0; i<NUMAI; i++)
		{
			addAI();
		}
	}


function addAI()
{
	var c = getMapSector(camera.position);
	var texture_enemy1 = THREE.ImageUtils.loadTexture( 'Enemy.jpg' );
	var material_enemy1 = new THREE.MeshBasicMaterial( {map: texture_enemy1, color:0xffffff} );
	var enemy1 = new THREE.Mesh( geometry_enemy1, material_enemy1 );

	do
	{
		var x = getRandBetween(0, mapW-1);
		var z = getRandBetween(0, mapH-1);
	}
	while (map[x][z] > 0 || (x == c.x && z == c.z));
	x = Math.floor(x - mapW/2) * UNITSIZE;
	z = Math.floor(z - mapW/2) * UNITSIZE;
	enemy1.position.set(x, UNITSIZE * 0.15, z);
	enemy1.pathPos = 1;
	enemy1.lastRandomX = Math.random();
	enemy1.lastRandomZ = Math.random();
	ai.push(enemy1);
	scene.add(enemy1);
}

function getAIpath(a)
{
	var p = getMapSector(a.position);
	do { // Cop-out
		do {
			var x = getRandBetween(0, mapW-1);
			var z = getRandBetween(0, mapH-1);
		} while (map[x][z] > 0 || distance(p.x, p.z, x, z) < 3);
		var path = findAIpath(p.x, p.z, x, z);
	} while (path.length == 0);
	return path;
}


function findAIpath(sX, sZ, eX, eZ)
{
	var backupGrid = grid.clone();
	var path = finder.findPath(sX, sZ, eX, eZ, grid);
	grid = backupGrid;
	return path;
}

function distance(x1, y1, x2, y2)
{
	return Math.sqrt((x2-x1)*(x2-x1)+(y2-y1)*(y2-y1));
}

function getMapSector(v)
{
	var x = Math.floor((v.x + UNITSIZE / 2) / UNITSIZE + mapW/2);
	var z = Math.floor((v.z + UNITSIZE / 2) / UNITSIZE + mapW/2);
	return {x: x, z: z};
}

function getRandBetween(lo, hi)
{
 return parseInt(Math.floor(Math.random()*(hi-lo+1))+lo, 10);
}



	//////////////////////////////////////////////////////////////////////////////////
	//		loop runner							//
	//////////////////////////////////////////////////////////////////////////////////
	var lastTimeMsec= null
	requestAnimationFrame(function animate(nowMsec){
		// keep looping
		requestAnimationFrame( animate );
		// measure time
		lastTimeMsec	= lastTimeMsec || nowMsec-1000/60
		var deltaMsec	= Math.min(200, nowMsec - lastTimeMsec)
		lastTimeMsec	= nowMsec

		                  function keyDown(event)
		                  {
                          keyboard[event.keyCode] = true;
                          }

                          function keyUp(event){
                          keyboard[event.keyCode] = false;
                          }

                          window.addEventListener('keydown', keyDown);
                          window.addEventListener('keyup', keyUp);




        // call each update function
		updateFcts.forEach(function(updateFn)
		{
			updateFn(deltaMsec/1000, nowMsec/1000)
		})


	})



    function castRays()
    {
            // rays

            var direction = new THREE.Vector3(1000, 5500, 1000);
            var startPoint = camera.position.clone();
            var directionVector = direction.sub( startPoint );
            var ray = new THREE.Raycaster(startPoint, directionVector.clone(). normalize());
            scene.updateMatrixWorld();		 // required, since you haven't rendered yet
            var rayIntersects = ray.intersectObjects(scene.children, true);
            if (rayIntersects.length > 0)
            {
                                 camera.position.z = camera.position.z - 5;
								 camera.position.x = camera.position.x - 5;

			}

		}

					function onDocumentMouseMove(e)
					{
						e.preventDefault();
						mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
						mouse.y = - (e.clientY / window.innerHeight) * 2 + 1;
					}




</script><canvas width="1440" height="757"></canvas>
</body></html>
